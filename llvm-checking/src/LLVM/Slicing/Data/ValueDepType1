{-# LANGUAGE FlexibleInstances,TypeSynonymInstances,MultiParamTypeClasses,
             FunctionalDependencies,TypeFamilies,FlexibleContexts,BangPatterns,
             DeriveGeneric,DeriveAnyClass,StandaloneDeriving   #-}
{-# OPTIONS_GHC -XUndecidableInstances #-}

module LLVM.Slicing.Data.ValueDepType where

import Control.DeepSeq  
--import GHC.Generics ( Generic )
--import Control.DeepSeq.Generics ( genericRnf,genericRnfV1 )
 
import Data.List  
import Data.IntSet (IntSet(..))
import qualified Data.IntSet as IS
--import Data.Map (Map)
--import qualified Data.Map as M
import Data.IntMap.Strict (IntMap)
import qualified Data.IntMap.Strict as IM

--import qualified LLVM.Slicing.Data.ROBDD.ROBDD as BDD
import LLVM.Slicing.Data.BDD  ( ROBDD )
import qualified LLVM.Slicing.Data.BDD as BDD

import Data.Array.Repa  ( Array )
import qualified Data.Array.Repa as Repa
import Data.Vector  (Vector,MVector)
import qualified Data.Vector as Vec


type ValueIdType = Int
  
class Eq a => IsValueIdSet a where
  type VSElm a
  emptyValIdSet  :: a
  elemValIdSet :: VSElm a -> a -> Bool 
  insertValIdSet :: VSElm a -> a -> a
  toListValIdSet :: a -> [VSElm a]
--  fromListValIdSet :: [VSElm a] -> a
--  sizeValIdSet :: Int
--  unitValIdSet   :: VSElm a -> a
--  unionValIdSet  :: a -> a -> a
--  unionsValIdSet :: [a] -> a

  fromListValIdSet :: [VSElm a] -> a 
  fromListValIdSet = foldl' (flip insertValIdSet) emptyValIdSet 
  
  sizeValIdSet :: a -> Int
  sizeValIdSet = length . toListValIdSet  
  
  unitValIdSet   :: VSElm a -> a
  unitValIdSet = flip insertValIdSet emptyValIdSet
  
  unionValIdSet  :: a -> a -> a
  unionValIdSet vs1 vs2 = if length lvs2 >= length lvs1 
     then foldl' (flip insertValIdSet) vs2 lvs1
     else foldl' (flip insertValIdSet) vs1 lvs2
    where  lvs1 = toListValIdSet vs1
           lvs2 = toListValIdSet vs2
  {-# INLINE unionValIdSet #-}
  unionsValIdSet :: [a] -> a
  unionsValIdSet = foldl' unionValIdSet emptyValIdSet
  {-# INLINE unionsValIdSet #-}


  
  
class (Eq (VDKey t),Ord (VDKey t),Show (VDKey t),IsValueIdSet b) => IsValueDepTable t b where
  data  VDTable t :: * -> *
  data  VDElm t b 
  type  VDKey t   
  toValIdSet :: VDElm t b -> b
  emptyValueDep :: VDTable t (VDElm t b)
  lkpValueDep   :: VDKey t -> VDTable t (VDElm t b) -> b
  insertWithValueDep :: (b -> b -> b) -> VDKey t -> b  
                        -> VDTable t (VDElm t b) -> VDTable t (VDElm t b)
  mrgWithKeyValueDep :: (VDKey t -> b -> b -> b) -> VDTable t (VDElm t b)
                        -> VDTable t (VDElm t b) -> VDTable t (VDElm t b)
  mapWithKeyValueDep :: (IsValueIdSet c) => (VDKey t -> b -> c) 
                      -> VDTable t (VDElm t b) -> VDTable t c
  toListValueDep   :: VDTable t (VDElm t b) -> [(VDKey t,b)]
--  updValueDep,xtdValueDep   :: VDKey t -> b -> VDTable t (VDElm t b) -> VDTable t (VDElm t b)
--  mrgValueDep  :: VDTable t (VDElm t b) -> VDTable t (VDElm t b) -> VDTable t (VDElm t b) 
--  mrgWithValueDep :: (b -> b -> b) -> VDTable t (VDElm t b) -> VDTable t (VDElm t b) -> VDTable t (VDElm t b)
--  mrgWithKeyValueDep2 :: (IsValueDepTable t b,VDKey t ~ VSElm b,Num (VSElm b))  
--                      => [VDKey t] -> VDTable t (VDElm t b) -> VDTable t (VDElm t b) -> VDTable t (VDElm t b)
--  unionLkpValueDep,unionLkpValueDep' ::  [VDKey t] -> VDTable t (VDElm t b) -> b
--  updsValueDep,xtdsValueDep :: [(VDKey t,b)] -> VDTable t (VDElm t b) -> VDTable t (VDElm t b) 
--  updsValueDep2,xtdsValueDep2 :: [VDKey t] -> b -> VDTable t (VDElm t b) -> VDTable t (VDElm t b)
--  fromListValueDep :: [(VDKey t,b)] -> VDTable t (VDElm t b)
--  fromIMapISetValueDep :: (VSElm b~Int,VDKey t~Int)=> IntMap IntSet -> VDTable t (VDElm t b)
--  toIMapISetValueDep   :: (VSElm b~Int,VDKey t~Int)=> VDTable t (VDElm t b) -> IntMap IntSet

  mrgValueDep  :: VDTable t (VDElm t b) -> VDTable t (VDElm t b) -> VDTable t (VDElm t b) 
  mrgValueDep = mrgWithValueDep unionValIdSet
  mrgWithValueDep :: (b -> b -> b) -> VDTable t (VDElm t b) -> 
                  VDTable t (VDElm t b) -> VDTable t (VDElm t b) 
  mrgWithValueDep fn = mrgWithKeyValueDep (\_ b1 b2 -> fn b1 b2)
  
  mrgWithKeyValueDep2 :: (IsValueDepTable t b,VDKey t ~ VSElm b,Num (VSElm b))  
                      => [VDKey t] -> VDTable t (VDElm t b) -> VDTable t (VDElm t b) -> VDTable t (VDElm t b)
  mrgWithKeyValueDep2 glbs vdM1 vdM2 =  mrgWithKeyValueDep mapF vdM1 vdM2  
    where mapF k lx' lx = let lxs' = toListValIdSet lx' in
                          if (elem k glbs) && (notElem lxs' [[],[-k]])  
                          then lx' else unionValIdSet lx' lx
          {-# INLINE mapF #-}
          
  unionLkpValueDep',unionLkpValueDep ::  [VDKey t] -> VDTable t (VDElm t b) -> b 
  unionLkpValueDep' ns vdM = unionsValIdSet $ map (flip lkpValueDep vdM) ns
  unionLkpValueDep ns vdM = case ns of 
           [] -> emptyValIdSet
           [n] -> lkpValueDep n vdM
           [n1,n2] -> unionValIdSet (lkpValueDep n1 vdM) (lkpValueDep n2 vdM)
           _   -> unionLkpValueDep' ns vdM 

  updValueDep,xtdValueDep  :: VDKey t -> b -> VDTable t (VDElm t b) -> VDTable t (VDElm t b)  
  updsValueDep,xtdsValueDep :: [(VDKey t,b)] -> VDTable t (VDElm t b) -> VDTable t (VDElm t b) 
  updsValueDep2,xtdsValueDep2 :: [VDKey t] -> b -> VDTable t (VDElm t b) -> VDTable t (VDElm t b) 
  updValueDep = insertWithValueDep const    
  xtdValueDep = insertWithValueDep unionValIdSet     
  updsValueDep nvds vdM = 
        foldl' (\vdM' (n,vd) -> updValueDep n vd vdM') vdM nvds 
  updsValueDep2 ns vd vdM =  
        foldl' (\vdM' n -> updValueDep n vd vdM') vdM ns
  xtdsValueDep nvds vdM = 
        foldl' (\vdM' (n,vd) -> xtdValueDep n vd vdM') vdM nvds 
  xtdsValueDep2 ns vd vdM =  
        foldl' (\vdM' n -> xtdValueDep n vd vdM') vdM ns 

  fromListValueDep :: [(VDKey t,b)] -> VDTable t (VDElm t b)   
  fromListValueDep nvds = updsValueDep nvds emptyValueDep   
      
  fromIMapISetValueDep :: (VSElm b ~ Int,VDKey t ~ Int) => IntMap IntSet -> VDTable t (VDElm t b)
  fromIMapISetValueDep idepMap = fromListValueDep $!
         [(n,fromListValIdSet $ IS.toList ls)|(n,ls) <- IM.toList idepMap] 
  toIMapISetValueDep   :: (VSElm b ~ Int,VDKey t ~ Int) => VDTable t (VDElm t b) -> IntMap IntSet
  toIMapISetValueDep vdM = IM.fromList $!
         [(n,IS.fromList $ toListValIdSet vd)|(n,vd) <- toListValueDep vdM]
        
 
--instance (Generic b,IsValueDepTable a b) => Generic (VDTable a b)
instance (Show b, IsValueDepTable a b) => Show (VDTable a (VDElm a b)) where 
   show vm = "VDTable: fromList " ++ show (toListValueDep vm)
instance (Eq b,IsValueDepTable a b) => Eq (VDTable a (VDElm a b)) where
   vm1 == vm2  = toListValueDep vm1 == toListValueDep vm2
instance (Ord b,IsValueDepTable a b) => Ord (VDTable a (VDElm a b)) where
   compare vm1 vm2  = compare (toListValueDep vm1) (toListValueDep vm2)      
instance IsValueDepTable a b => NFData (VDTable a (VDElm t b)) where
   rnf !_ = ()     -- genericRnf  



----
instance IsValueIdSet IntSet where
  type VSElm IntSet = Int
  emptyValIdSet  = IS.empty
  unionValIdSet  = IS.union
  {-# INLINE unionValIdSet #-}
  unionsValIdSet = IS.unions
  elemValIdSet = IS.member 
  insertValIdSet = IS.insert
  unitValIdSet   = IS.singleton
  sizeValIdSet   = IS.size
  toListValIdSet = IS.toList
  fromListValIdSet = IS.fromList

instance IsValueIdSet ROBDD where
  type VSElm ROBDD = ValueIdType
  emptyValIdSet  = BDD.makeFalse
  unionValIdSet  = BDD.mrgBDD    -- BDD.or
  unionsValIdSet = BDD.mrgBDDs
  elemValIdSet = BDD.elemBDD
  insertValIdSet = BDD.mrgBDD
  unitValIdSet   = BDD.toBDD
  toListValIdSet = BDD.fromBDD
  fromListValIdSet = BDD.toBDD

instance (Eq b,Ord b,IsValueIdSet b) => IsValueIdSet [b] where
  type VSElm [b] = b
  emptyValIdSet  = []
  elemValIdSet = elem 
  insertValIdSet v vs = if elem v vs then vs else v:vs
  unionValIdSet  = union
  unitValIdSet   = (:[])
  sizeValIdSet  = length
  toListValIdSet = id
  fromListValIdSet = id

instance (Eq b,Ord b,IsValueIdSet b) => IsValueIdSet [(ValueIdType,b)] where
  type VSElm [(ValueIdType,b)] = (ValueIdType,b)
  emptyValIdSet  = []
  elemValIdSet = elem 
  toListValIdSet = id
  insertValIdSet = insertWith unionValIdSet
    where insertWith _ nv [] = [nv]
          insertWith fn nv@(n,v) nvs@((n',v'):nvs')
        --     | (n',v') == (n,v) = nvs 
             | n' == n    = (n, fn v v'):nvs'
             | otherwise  = (n',v'): (insertWith fn nv nvs')
  {-# INLINE insertValIdSet #-}
  unitValIdSet   = (:[])
  sizeValIdSet  = length
--  unionValIdSet  = union
--  fromListValIdSet = id  

instance (Eq b) => IsValueIdSet (Vector b) where
  type VSElm (Vector b) = b
  emptyValIdSet  = Vec.empty
  elemValIdSet = Vec.elem 
  insertValIdSet v vs = 
     if Vec.elem v vs then vs else Vec.cons v vs
--  unionValIdSet  = (Vec.++)
--  unionsValIdSet = Vec.concat
  unitValIdSet   = Vec.singleton
  sizeValIdSet   = Vec.length
  toListValIdSet = Vec.toList
  fromListValIdSet = Vec.fromList
  
---
data IntMap_ = IntMap_ deriving (Show,Read)
data Vector_ = Vector_ deriving (Show,Read)
data MVector_ = MVector_ deriving (Show,Read)

instance IsValueIdSet b => IsValueDepTable IntMap_ b where
  data VDTable IntMap_ v = VD_IntMap (IntMap v) 
  data VDElm IntMap_ b = Elm_IntMap b  
  type VDKey IntMap_ = Int
  toValIdSet (Elm_IntMap v) = v
  emptyValueDep = VD_IntMap IM.empty 
  lkpValueDep vn (VD_IntMap vdM) = 
     toValIdSet $ IM.findWithDefault (Elm_IntMap emptyValIdSet) vn vdM
  mapWithKeyValueDep fn (VD_IntMap vdM) = VD_IntMap (IM.mapWithKey mapF vdM)
     where  mapF k v1 = Elm_IntMap (fn k v1)
  toListValueDep (VD_IntMap vdM) = IM.toList vdM
  mrgWithKeyValueDep fn (VD_IntMap vdM1) (VD_IntMap vdM2) = 
         VD_IntMap (IM.unionWithKey fn vdM1 vdM2)
  insertWithValueDep fn n v (VD_IntMap vdM) = VD_IntMap (IM.insertWith fn n v vdM)
  {-# INLINE xtdValueDep #-}          
  unionLkpValueDep' vs (VD_IntMap vdM)  = let keyF k _ = elem k vs  in
                unionsValIdSet. IM.elems $ IM.filterWithKey keyF vdM
  {-# INLINE unionLkpValueDep' #-}

{-
instance IsValueIdSet b => IsValueDepTable Vector_ b where
  data VDTable Vector_ v  = VD_Vector (Vector (ValueIdType,v))  
  type VDKey Vector_ = ValueIdType
  type VDElm Vector_ b = (ValueIdType,b)
  toValIdSet = snd
  emptyValueDep = VD_Vector Vec.empty 
  lkpValueDep n (VD_Vector nvs) = 
    unionsValIdSet. Vec.toList $ Vec.filter ((==n). fst) nvs
--     where  (ns,vs) = Vec.unzip nvs 
--            idxs = Vec.elemIndices n ns
--            n_vs = Vec.force $ Vec.backpermute vs idxs
--            result = unionsValIdSet $ Vec.toList n_vs
  insertWithValueDep fn n v (VD_Vector nvs) = VD_Vector nvs'
      where  (nvs1,nvs2) = Vec.partition ((==n). fst) nvs
             n_v = unionsValIdSet $ Vec.toList nvs1
             nvs' = if Vec.null nvs1 
                    then Vec.cons (n,v) nvs
                    else Vec.snoc nvs2 (n, fn v n_v)             
  mrgWithKeyValueDep = undefined
  mapWithKeyValueDep = undefined
  toListValueDep (VD_Vector nvs) = Vec.toList nvs
  fromListValueDep = VD_Vector . Vec.fromList
-}



  