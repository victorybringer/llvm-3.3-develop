<!DOCTYPE html>
<html><head><title>summarize [function breakdown]</title>
<link rel="stylesheet" href="../style.css" type="text/css">
<link rel="stylesheet" href="../jquery.snippet.css" type="text/css">
<script type="text/javascript" src="../jquery-1.8.2.min.js"></script>
<script type="text/javascript" src="../jquery.snippet.js"></script>
<script type="text/javascript" src="../highlight.js"></script>
</head>
<body>Breakdown of summarize (defined in /root/文档/myTests/bench/time-1.7/time.c)
<div><ul><li><span class="code-type">%struct._IO_FILE*<a href="#" onclick="editor.highlightText('highlight', 'fp');">fp</a>
</span>
</li>
<li><span class="code-type">i8*<a href="#" onclick="editor.highlightText('highlight', 'fmt');">fmt</a>
<span class="code-comment"> /* [ PAArray 1 ] */ </span> </span>
</span>
</li>
<li><span class="code-type">i8**<a href="#" onclick="editor.highlightText('highlight', 'command');">command</a>
<span class="code-comment"> /* [ PAArray 2 ] */ </span> </span>
</span>
</li>
<li><span class="code-type">%struct.RESUSE*<a href="#" onclick="editor.highlightText('highlight', 'resp');">resp</a>
<span class="code-comment"> /* [ <a href="#" onclick="highlightLines(321, [[330, 'deref'],[345, 'deref'],[345, 'deref'],[347, 'deref'],[347, 'deref'],[347, 'deref'],[347, 'deref'],[366, 'deref'],[367, 'deref'],[370, 'deref'],[376, 'deref'],[382, 'deref'],[385, 'deref'],[390, 'deref'],[391, 'deref'],[392, 'deref'],[395, 'deref'],[398, 'deref'],[408, 'deref'],[411, 'deref'],[411, 'deref'],[416, 'deref'],[416, 'deref'],[421, 'deref'],[426, 'deref'],[432, 'deref'],[435, 'deref'],[435, 'deref'],[440, 'deref'],[445, 'deref'],[448, 'deref'],[451, 'deref'],[456, 'deref'],[459, 'deref'],[462, 'deref']]);">PANotNull </a>
 ] */ </span> </span>
</span>
</li>
</ul>
</div>
<p>summarize (<span class="code-type">%struct._IO_FILE*</span> fp</span>
, <span class="code-type">i8*</span> fmt</span>
, <span class="code-type">i8**</span> command</span>
, <span class="code-type">%struct.RESUSE*</span> resp</span>
) -> <span class="code-type">void</span></p>
<pre id="code" name="code">{
  unsigned long r;    /* Elapsed real milliseconds.  */
  unsigned long v;    /* Elapsed virtual (CPU) milliseconds.  */

  if (WIFSTOPPED (resp-&gt;waitstatus))
    fprintf (fp, &quot;Command stopped by signal %d\n&quot;,
       WSTOPSIG (resp-&gt;waitstatus));
  else if (WIFSIGNALED (resp-&gt;waitstatus))
    fprintf (fp, &quot;Command terminated by signal %d\n&quot;,
       WTERMSIG (resp-&gt;waitstatus));
  else if (WIFEXITED (resp-&gt;waitstatus) &amp;&amp; WEXITSTATUS (resp-&gt;waitstatus))
    fprintf (fp, &quot;Command exited with non-zero status %d\n&quot;,
       WEXITSTATUS (resp-&gt;waitstatus));

  /* Convert all times to milliseconds.  Occasionally, one of these values
     comes out as zero.  Dividing by zero causes problems, so we first
     check the time value.  If it is zero, then we take `evasive action&#39;
     instead of calculating a value.  */

  r = resp-&gt;elapsed.tv_sec * 1000 + resp-&gt;elapsed.tv_usec / 1000;

  v = resp-&gt;ru.ru_utime.tv_sec * 1000 + resp-&gt;ru.ru_utime.TV_MSEC +
    resp-&gt;ru.ru_stime.tv_sec * 1000 + resp-&gt;ru.ru_stime.TV_MSEC;

  while (*fmt)
    {
      switch (*fmt)
  {
  case &#39;%&#39;:
    switch (*++fmt)
      {
      case &#39;%&#39;:    /* Literal &#39;%&#39;.  */
        putc (&#39;%&#39;, fp);
        break;
      case &#39;C&#39;:    /* The command that got timed.  */
        fprintargv (fp, command, &quot; &quot;);
        break;
      case &#39;D&#39;:    /* Average unshared data size.  */
        fprintf (fp, &quot;%lu&quot;,
           MSEC_TO_TICKS (v) == 0 ? 0 :
           ptok ((UL) resp-&gt;ru.ru_idrss) / MSEC_TO_TICKS (v) +
           ptok ((UL) resp-&gt;ru.ru_isrss) / MSEC_TO_TICKS (v));
        break;
      case &#39;E&#39;:    /* Elapsed real (wall clock) time.  */
        if (resp-&gt;elapsed.tv_sec &gt;= 3600)  /* One hour -&gt; h:m:s.  */
    fprintf (fp, &quot;%ld:%02ld:%02ld&quot;,
       resp-&gt;elapsed.tv_sec / 3600,
       (resp-&gt;elapsed.tv_sec % 3600) / 60,
       resp-&gt;elapsed.tv_sec % 60);
        else
    fprintf (fp, &quot;%ld:%02ld.%02ld&quot;,  /* -&gt; m:s.  */
       resp-&gt;elapsed.tv_sec / 60,
       resp-&gt;elapsed.tv_sec % 60,
       resp-&gt;elapsed.tv_usec / 10000);
        break;
      case &#39;F&#39;:    /* Major page faults.  */
        fprintf (fp, &quot;%ld&quot;, resp-&gt;ru.ru_majflt);
        break;
      case &#39;I&#39;:    /* Inputs.  */
        fprintf (fp, &quot;%ld&quot;, resp-&gt;ru.ru_inblock);
        break;
      case &#39;K&#39;:    /* Average mem usage == data+stack+text.  */
        fprintf (fp, &quot;%lu&quot;,
           MSEC_TO_TICKS (v) == 0 ? 0 :
           ptok ((UL) resp-&gt;ru.ru_idrss) / MSEC_TO_TICKS (v) +
           ptok ((UL) resp-&gt;ru.ru_isrss) / MSEC_TO_TICKS (v) +
           ptok ((UL) resp-&gt;ru.ru_ixrss) / MSEC_TO_TICKS (v));
        break;
      case &#39;M&#39;:    /* Maximum resident set size.  */
        fprintf (fp, &quot;%lu&quot;, ptok ((UL) resp-&gt;ru.ru_maxrss));
        break;
      case &#39;O&#39;:    /* Outputs.  */
        fprintf (fp, &quot;%ld&quot;, resp-&gt;ru.ru_oublock);
        break;
      case &#39;P&#39;:    /* Percent of CPU this job got.  */
        /* % cpu is (total cpu time)/(elapsed time).  */
        if (r &gt; 0)
    fprintf (fp, &quot;%lu%%&quot;, (v * 100 / r));
        else
    fprintf (fp, &quot;?%%&quot;);
        break;
      case &#39;R&#39;:    /* Minor page faults (reclaims).  */
        fprintf (fp, &quot;%ld&quot;, resp-&gt;ru.ru_minflt);
        break;
      case &#39;S&#39;:    /* System time.  */
        fprintf (fp, &quot;%ld.%02ld&quot;,
           resp-&gt;ru.ru_stime.tv_sec,
           resp-&gt;ru.ru_stime.TV_MSEC / 10);
        break;
      case &#39;U&#39;:    /* User time.  */
        fprintf (fp, &quot;%ld.%02ld&quot;,
           resp-&gt;ru.ru_utime.tv_sec,
           resp-&gt;ru.ru_utime.TV_MSEC / 10);
        break;
      case &#39;W&#39;:    /* Times swapped out.  */
        fprintf (fp, &quot;%ld&quot;, resp-&gt;ru.ru_nswap);
        break;
      case &#39;X&#39;:    /* Average shared text size.  */
        fprintf (fp, &quot;%lu&quot;,
           MSEC_TO_TICKS (v) == 0 ? 0 :
           ptok ((UL) resp-&gt;ru.ru_ixrss) / MSEC_TO_TICKS (v));
        break;
      case &#39;Z&#39;:    /* Page size.  */
        fprintf (fp, &quot;%d&quot;, getpagesize ());
        break;
      case &#39;c&#39;:    /* Involuntary context switches.  */
        fprintf (fp, &quot;%ld&quot;, resp-&gt;ru.ru_nivcsw);
        break;
      case &#39;e&#39;:    /* Elapsed real time in seconds.  */
        fprintf (fp, &quot;%ld.%02ld&quot;,
           resp-&gt;elapsed.tv_sec,
           resp-&gt;elapsed.tv_usec / 10000);
        break;
      case &#39;k&#39;:    /* Signals delivered.  */
        fprintf (fp, &quot;%ld&quot;, resp-&gt;ru.ru_nsignals);
        break;
      case &#39;p&#39;:    /* Average stack segment.  */
        fprintf (fp, &quot;%lu&quot;,
           MSEC_TO_TICKS (v) == 0 ? 0 :
           ptok ((UL) resp-&gt;ru.ru_isrss) / MSEC_TO_TICKS (v));
        break;
      case &#39;r&#39;:    /* Incoming socket messages received.  */
        fprintf (fp, &quot;%ld&quot;, resp-&gt;ru.ru_msgrcv);
        break;
      case &#39;s&#39;:    /* Outgoing socket messages sent.  */
        fprintf (fp, &quot;%ld&quot;, resp-&gt;ru.ru_msgsnd);
        break;
      case &#39;t&#39;:    /* Average resident set size.  */
        fprintf (fp, &quot;%lu&quot;,
           MSEC_TO_TICKS (v) == 0 ? 0 :
           ptok ((UL) resp-&gt;ru.ru_idrss) / MSEC_TO_TICKS (v));
        break;
      case &#39;w&#39;:    /* Voluntary context switches.  */
        fprintf (fp, &quot;%ld&quot;, resp-&gt;ru.ru_nvcsw);
        break;
      case &#39;x&#39;:    /* Exit status.  */
        fprintf (fp, &quot;%d&quot;, WEXITSTATUS (resp-&gt;waitstatus));
        break;
      case &#39;\0&#39;:
        putc (&#39;?&#39;, fp);
        return;
      default:
        putc (&#39;?&#39;, fp);
        putc (*fmt, fp);
      }
    ++fmt;
    break;

  case &#39;\\&#39;:    /* Format escape.  */
    switch (*++fmt)
      {
      case &#39;t&#39;:
        putc (&#39;\t&#39;, fp);
        break;
      case &#39;n&#39;:
        putc (&#39;\n&#39;, fp);
        break;
      case &#39;\\&#39;:
        putc (&#39;\\&#39;, fp);
        break;
      default:
        putc (&#39;?&#39;, fp);
        putc (&#39;\\&#39;, fp);
        putc (*fmt, fp);
      }
    ++fmt;
    break;

  default:
    putc (*fmt++, fp);
  }

      if (ferror (fp))
  error (1, errno, &quot;write error&quot;);
    }
  putc (&#39;\n&#39;, fp);

  if (ferror (fp))
    error (1, errno, &quot;write error&quot;);
}</pre>
<script type="text/javascript">
$(window).bind("load", function() {
  $("pre#code").snippet("c", {style: "emacs", showNum: true, startNum: 321});
  initializeHighlighting();
  linkCalledFunctions([['fprintargv', 'fprintargv'], ['ptok', 'ptok'], ['ptok', 'ptok'], ['ptok', 'ptok'], ['ptok', 'ptok'], ['ptok', 'ptok'], ['ptok', 'ptok'], ['ptok', 'ptok'], ['ptok', 'ptok'], ['ptok', 'ptok'], ['error', 'error'], ['error', 'error']]);
  });
</script>
</body>
</html>
